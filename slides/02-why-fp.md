Why FP
------

* Simple to reason about
 - inputs yield outputs
 - data and behavior are the same

* Simple to decompose
 - functions are truly first class
 - when everything is composed of functions/data powerful patterns of abstraction become available
 - currying

* Simple to compose
  - partial application | a function without all it's arguments simply returns a function expecting those additional args
  - (implicit in ML style languages, explicit in lisps/clojure)

* Composition leads to reuse
  - Almost anything you can imagine writing that's a general operation, you will almost certainly see that it was available to you before hand.
  - Learn to recognize patterns and be tickled by them, intuit that someone smarter than you has probably solved this.

* Programming, motherfucker
 - it matters
 - ...the more you know!
 - exposure and experimentation build & refine tastes
 - Do you have an argument for not knowing more? Is putting the shoe on the other foot a bad idea sometimes?
